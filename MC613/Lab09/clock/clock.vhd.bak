library ieee;
use ieee.std_logic_1164.all;

entity clock is
  port (
    clk : in std_logic;
    decimal : in std_logic_vector(3 downto 0);
    unity : in std_logic_vector(3 downto 0);
    set_hour : in std_logic;
    set_minute : in std_logic;
    set_second : in std_logic;
    hour_dec, hour_un : out std_logic_vector(6 downto 0);
    min_dec, min_un : out std_logic_vector(6 downto 0);
    sec_dec, sec_un : out std_logic_vector(6 downto 0)
  );
end clock;

architecture rtl of clock is
  component clk_div is
    port (
      clk : in std_logic;
      clk_hz : out std_logic
    );
  end component;
  signal clk_hz : std_logic;

  component clk_div_min is
    port (
      clk_hz : in std_logic;
      clk_min : out std_logic
    );
  end component;
  signal clk_min : std_logic;

  component clk_div_hour is
    port (
      clk_hz : in std_logic;
      clk_hour : out std_logic
    );
  end component;
  signal clk_hour : std_logic;
  
  component bin2hex is
    port (
          bin: in std_logic_vector(3 downto 0);
          hex: out std_logic_vector(6 downto 0)
    );
  end component;

  component reg is
    generic (
      N : integer := 4
    );
    port (
      clk : in std_logic;
      data_in : in std_logic_vector(N-1 downto 0);
      data_out : out std_logic_vector(N-1 downto 0);
      load : in std_logic; -- Write enable
      clear : in std_logic
    );
  end component;

  component ripple_carry is
    generic (
      N : integer := 4
    );
    port (
      x,y : in std_logic_vector(N-1 downto 0);
      r : out std_logic_vector(N-1 downto 0);
      cin : in std_logic;
      cout : out std_logic;
      overflow : out std_logic
    );
  end component; 

  component valid_h is
    port (
      decimal : in std_logic_vector(3 downto 0);
      unity : in std_logic_vector(3 downto 0);
      valid: out std_logic
    );
  end component;

  component valid_ms is
    port (
      decimal : in std_logic_vector(3 downto 0);
      unity : in std_logic_vector(3 downto 0);
      valid: out std_logic
    );
  end component;

  -- Sinais auxiliares
  signal in_hd, in_hu, in_md, in_mu, in_sd, in_su : std_logic_vector(3 downto 0);
  signal sum_hd, sum_hu, sum_md, sum_mu, sum_sd, sum_su : std_logic_vector(3 downto 0);
  signal vsum_hd, vsum_hu, vsum_md, vsum_mu, vsum_sd, vsum_su: std_logic_vector(3 downto 0);
  signal valid_h_out, valid_ms_out, v_s_out, v_m_out, v_h_out: std_logic;
  signal co_hd, co_hu, co_md, co_mu, co_sd, co_su: std_logic;
  signal ov_hd, ov_hu, ov_md, ov_mu, ov_sd, ov_su: std_logic;


begin

  -- Clock para cada componente do horário, usados para somar 1 ou não ao valor atual
  clock_sec : clk_div port map (clk, clk_hz);
  clock_min : clk_div_min port map (clk_hz, clk_min);
  clock_hour : clk_div_hour port map (clk_hz, clk_hour);

  v_ms: valid_ms port map(decimal, unity, valid_ms_out);
  v_h: valid_h port map(decimal, unity, valid_h_out);

  v_ns: valid_ms port map(sum_sd, sum_su, v_s_out);
  v_nm: valid_ms port map(sum_md, sum_mu, v_m_out);
  v_nh: valid_h port map(sum_hd, sum_hu, v_h_out);

  -- Registradores de dezenas e unidades de horas, minutos e segundos
  reg_sd : reg generic map (N => 7) port map (clk, "000" & in_sd, sec_dec, set_second, '0');
  reg_su : reg generic map (N => 7) port map (clk, "000" & in_su, sec_un, set_second, '0');
  reg_md : reg generic map (N => 7) port map (clk, "000" & in_md, min_dec, set_minute, '0');
  reg_mu : reg generic map (N => 7) port map (clk, "000" & in_mu, min_un, set_minute, '0');
  reg_hd : reg generic map (N => 7) port map (clk, "000" & in_hd, hour_dec, set_hour, '0');
  reg_hu : reg generic map (N => 7) port map (clk, "000" & in_hu, hour_un, set_hour, '0');


  -- Uma das entradas dos ripple carry será "000" & clock, a outra será a propria soma
  adder_sd : ripple_carry generic map (N => 4) port map ("000" & clk_hz, vsum_sd, sum_sd, '0', co_sd, ov_sd);
  adder_su : ripple_carry generic map (N => 4) port map ("000" & clk_hz, vsum_su, sum_su, '0', co_su, ov_su);
  adder_md : ripple_carry generic map (N => 4) port map ("000" & clk_min, vsum_md, sum_md, '0', co_md, ov_md);
  adder_mu : ripple_carry generic map (N => 4) port map ("000" & clk_min, vsum_mu, sum_mu, '0', co_mu, ov_mu);
  adder_hd : ripple_carry generic map (N => 4) port map ("000" & clk_hour, vsum_hd, sum_hd, '0', co_hd, ov_hd);
  adder_hu : ripple_carry generic map (N => 4) port map ("000" & clk_hour, vsum_hu, sum_hu, '0', co_hu, ov_hu);


  -- Seleciona os sinais de entrada nos registradores de hora
  with set_hour & valid_h_out select
    in_hd <=  decimal when "11",
              sum_hd when others;
  with set_hour & valid_h_out select
    in_hu <=  unity when '1',
              sum_hu when others;

  -- Seleciona os sinais de entrada nos registradores de minutos
  with set_minute & valid_ms_out select
    in_md <=  decimal when "11",
              sum_md when others;
  with set_minute & valid_ms_out select
    in_mu <=  unity when "11",
              sum_mu when others;

  -- Seleciona os sinais de entrada nos registradores de segundos
  with set_second & valid_ms_out select
    in_sd <=  decimal when "11",
              sum_sd when others;
  with set_second & valid_ms_out select
    in_su <=  unity when "11",
              sum_su when others;

  -- With select para determinar se sum_xx já passou do limite e deve-se zerar
  with v_s_out select
    vsum_sd <= '0' when '0',
               sum_sd when others;

  with v_s_out select
    vsum_su <= '0' when '0',
               sum_su when others;

  with v_m_out select
    vsum_md <= '0' when '0',
               sum_md when others;

  with v_m_out select
    vsum_mu <= '0' when '0',
               sum_mu when others;

  with v_h_out select
    vsum_hd <= '0' when '0',
               sum_hd when others;
  
  with v_h_out select
    vsum_hu <= '0' when '0',
               sum_hu when others;

end rtl;
